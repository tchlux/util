import time, os, sys, subprocess


MAX_FILE_SIZE_BYTES = 50*(2**20)
CHUNK_EXT = "_(part_%i_of_%i).chunk"
class FileTooSmall(Exception): pass

# Disassemble a file larger than "max_size" into chunks of size
# "max_size" having extension names generated by "chunk_ext".
# 
# ARGUMENTS:
#   file_path -- A string representing an absolute or relative path to
#                a file.
# 
# OPTIONAL:
#   max_size_bytes -- An integer representing the maximum number of
#                     bytes that a file chunk can contain.
#   chunk_ext      -- A string that contains two '%i' for formatting
#                     chunk extensions in the form "part %i of %i".
#   verbose        -- Prints out status information when set to True.
def disassemble(file_path, max_size_bytes=MAX_FILE_SIZE_BYTES,
                chunk_ext=CHUNK_EXT, verbose=True):
    size = os.path.getsize(file_path)
    chunks = int(size / max_size_bytes + 0.5)
    if (chunks <= 1): raise(FileTooSmall("The provided file is smaller than 'max_size'."))
    if verbose:
        print()
        print("File path:  ", file_path)
        print("File size:  ", size)
        print("File chunks:", chunks)
    with open(file_path, "rb") as f:
        for c in range(1,chunks+1):
            # Open the output file (with appropriate name) and read
            # out a chunk to that output file.
            with open(file_path+chunk_ext%(c,chunks), "wb") as out:
                if verbose:
                    print(" writing chunk %i of %i in '%s'..."%(c,chunks,out.name))
                out.write(f.read(max_size_bytes))
           

# Execute a blocking command with a subprocess, on completion provide
# the return code, stdout as string, and stderr as string. This should
# work across both Python2.7 and Python3.x as well as cross-platform.
#  INPUT:
#   command -- A list of strings or string (space separated) describing
#              a standard command as would be given to subprocess.Popen
# 
#  OUTPUT:
#   return_code -- Straight from the subprocess returncode
#   stdout      -- A list of strings that are the lines of stdout 
#                  produced by the execution of <command>
#   stderr      -- A list of strings that are the lines of stderr
#                  produced by the execution of <command>
def run(command, **popen_kwargs):
    # For Python 2.x the encoding is a string by default
    # For Python 3.6 and later the encoding can be given as an arguemnt
    if sys.version_info >= (3,6):
        popen_kwargs.update( dict(encoding="UTF-8") )
    proc = subprocess.Popen(command, stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE, **popen_kwargs)
    stdout, stderr = proc.communicate()
    # Before python 3.6, the encoding had to be handled after collection
    if ((sys.version_info >= (3,)) and (sys.version_info[0] == 3)):
        if (type(stdout) != str): stdout = str(stdout, encoding="UTF-8")
        if (type(stderr) != str): stderr = str(stderr, encoding="UTF-8")
    # Remove windows specific characters and split by the new line
    if stdout: stdout = stdout.replace("\r","").split("\n")
    else:      stdout = ""
    if stderr: stderr = stderr.replace("\r","").split("\n")
    else:      stderr = ""
    # Return the exit code, standard out, and standard error
    return proc.returncode, stdout, stderr


# ==========================
#      AtomicOpen Class     
# ==========================

try:
    # Posix based file locking (Linux, Ubuntu, MacOS, etc.)
    import fcntl
    def lock_file(f):
        try:
            fcntl.lockf(f, fcntl.LOCK_EX)
        except OSError:
            pass
    def unlock_file(f): pass
except ModuleNotFoundError:
    # Windows file locking
    import msvcrt
    def file_size(f):
        return os.path.getsize( os.path.realpath(f.name) )
    def lock_file(f):
        msvcrt.locking(f.fileno(), msvcrt.LK_RLCK, file_size(f))
    def unlock_file(f):
        msvcrt.locking(f.fileno(), msvcrt.LK_UNLCK, file_size(f))


# Class for ensuring that all file operations are atomic, treat
# initialization like a standard call to 'open' that happens to be atomic
class AtomicOpen:
    # First acquire a lock for the file, then open the file with
    # arguments provided by user. Attempts to inherit most of the file
    # properties, but use "__enter__" to get file object directly.
    def __init__(self, path, *args, **kwargs):
        writing = False
        if (len(args) > 0) and (args[0]) == "w": 
            writing = True
            args = tuple((a if (a != "w") else "a") for a in args)
        # Open the file and acquire a lock on the file before operating
        self.file = open(path,*args, **kwargs)
        # Lock the opened file
        lock_file(self.file)
        # If the user wanted to write (overwrite existing contents),
        # make sure that we are doing that exactly (after locking)
        if writing:
            self.file.seek(0)
            self.file.truncate()

    # Return the opened file object (knowing a lock has been obtained)
    def __enter__(self, *args, **kwargs): return self.file

    # Allows users to use the 'close' function if they want, in case
    # the user did not have the AtomicOpen in a "with" block.
    def close(self): self.__exit__()

    # Unlock the file and close the file object
    def __exit__(self, exc_type=None, exc_value=None, traceback=None):        
        # Release the lock on the file
        unlock_file(self.file)
        self.file.close()
        # Handle exceptions that may have come up during execution, by
        # default any exceptions are raised to the user
        if (exc_type != None): return False
        else:                  return True        
