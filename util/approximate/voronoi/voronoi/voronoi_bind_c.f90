! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).


SUBROUTINE C_EVAL_MESH(INT_PRODS_DIM_1, INT_PRODS_DIM_2, INT_PRODS, APP_INT_PRODS_DIM_1, APP_INT_PRODS_DIM_2, APP_INT_PRODS, MESH_D&
&IM_1, MESH_DIM_2, MESH) BIND(C)
  USE ISO_FORTRAN_ENV , ONLY : REAL64
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: INT_PRODS_DIM_1
  INTEGER, INTENT(IN) :: INT_PRODS_DIM_2
  REAL(KIND=REAL64), INTENT(IN), DIMENSION(INT_PRODS_DIM_1,INT_PRODS_DIM_2) :: INT_PRODS
  INTEGER, INTENT(IN) :: APP_INT_PRODS_DIM_1
  INTEGER, INTENT(IN) :: APP_INT_PRODS_DIM_2
  REAL(KIND=REAL64), INTENT(IN), DIMENSION(APP_INT_PRODS_DIM_1,APP_INT_PRODS_DIM_2) :: APP_INT_PRODS
  INTEGER, INTENT(IN) :: MESH_DIM_1
  INTEGER, INTENT(IN) :: MESH_DIM_2
  REAL(KIND=REAL64), INTENT(OUT), DIMENSION(MESH_DIM_1,MESH_DIM_2) :: MESH

  INTERFACE
    SUBROUTINE EVAL_MESH(INT_PRODS, APP_INT_PRODS, MESH)
      USE ISO_FORTRAN_ENV , ONLY : REAL64
      IMPLICIT NONE
      REAL(KIND=REAL64), INTENT(IN), DIMENSION(:,:) :: INT_PRODS
      REAL(KIND=REAL64), INTENT(IN), DIMENSION(:,:) :: APP_INT_PRODS
      REAL(KIND=REAL64), INTENT(OUT), DIMENSION(SIZE(APP_INT_PRODS,1),SIZE(INT_PRODS,1)) :: MESH
    END SUBROUTINE EVAL_MESH
  END INTERFACE

  CALL EVAL_MESH(INT_PRODS, APP_INT_PRODS, MESH)
END SUBROUTINE C_EVAL_MESH


SUBROUTINE C_MAKE_HUGE(DOTS_DIM_1, DOTS_DIM_2, DOTS) BIND(C)
  USE ISO_FORTRAN_ENV , ONLY : REAL64
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: DOTS_DIM_1
  INTEGER, INTENT(IN) :: DOTS_DIM_2
  REAL(KIND=REAL64), INTENT(OUT), DIMENSION(DOTS_DIM_1,DOTS_DIM_2) :: DOTS

  INTERFACE
    SUBROUTINE MAKE_HUGE(DOTS)
      USE ISO_FORTRAN_ENV , ONLY : REAL64
      REAL(KIND=REAL64), INTENT(OUT), DIMENSION(:,:) :: DOTS
    END SUBROUTINE MAKE_HUGE
  END INTERFACE

  CALL MAKE_HUGE(DOTS)
END SUBROUTINE C_MAKE_HUGE


SUBROUTINE C_PREDICT(POINTS_DIM_1, POINTS_DIM_2, POINTS, DOTS_DIM_1, DOTS_DIM_2, DOTS, EVAL_PT_DIM_1, EVAL_PT, WEIGHTS_DIM_1, WEIGH&
&TS, ERROR) BIND(C)
  USE ISO_FORTRAN_ENV , ONLY : REAL64
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: POINTS_DIM_1
  INTEGER, INTENT(IN) :: POINTS_DIM_2
  REAL(KIND=REAL64), INTENT(IN), DIMENSION(POINTS_DIM_1,POINTS_DIM_2) :: POINTS
  INTEGER, INTENT(IN) :: DOTS_DIM_1
  INTEGER, INTENT(IN) :: DOTS_DIM_2
  REAL(KIND=REAL64), INTENT(INOUT), DIMENSION(DOTS_DIM_1,DOTS_DIM_2) :: DOTS
  INTEGER, INTENT(IN) :: EVAL_PT_DIM_1
  REAL(KIND=REAL64), INTENT(IN), DIMENSION(EVAL_PT_DIM_1) :: EVAL_PT
  INTEGER, INTENT(IN) :: WEIGHTS_DIM_1
  REAL(KIND=REAL64), INTENT(OUT), DIMENSION(WEIGHTS_DIM_1) :: WEIGHTS
  INTEGER, INTENT(OUT) :: ERROR

  INTERFACE
    SUBROUTINE PREDICT(POINTS, DOTS, EVAL_PT, WEIGHTS, ERROR)
      ! Given column-vector POINTS, pairwise dot product matrix DOTS, and
      ! a single evaluation point EVAL_PT, compute the WEIGHTS associated
      ! with each input point.
      USE ISO_FORTRAN_ENV , ONLY : REAL64
      IMPLICIT NONE
      REAL(KIND=REAL64), INTENT(IN), DIMENSION(:,:) :: POINTS
      REAL(KIND=REAL64), INTENT(INOUT), DIMENSION(SIZE(POINTS,2),SIZE(POINTS,2)) :: DOTS
      REAL(KIND=REAL64), INTENT(IN), DIMENSION(SIZE(POINTS,1)) :: EVAL_PT
      REAL(KIND=REAL64), INTENT(OUT), DIMENSION(SIZE(POINTS,2)) :: WEIGHTS
      INTEGER, INTENT(OUT) :: ERROR
    END SUBROUTINE PREDICT
  END INTERFACE

  CALL PREDICT(POINTS, DOTS, EVAL_PT, WEIGHTS, ERROR)
END SUBROUTINE C_PREDICT

