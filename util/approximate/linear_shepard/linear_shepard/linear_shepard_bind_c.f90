! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).


MODULE C_REAL_PRECISION
  IMPLICIT NONE


CONTAINS


  ! Getter and setter for R8.
  SUBROUTINE REAL_PRECISION_GET_R8(R8_LOCAL) BIND(C)
    USE REAL_PRECISION, ONLY: R8
    INTEGER :: R8_LOCAL
    R8_LOCAL = R8
  END SUBROUTINE REAL_PRECISION_GET_R8
END MODULE C_REAL_PRECISION


MODULE C_LINEAR_SHEPARD_MOD
  IMPLICIT NONE


CONTAINS


  
  SUBROUTINE C_LSHEP(M, N, X_DIM_1, X_DIM_2, X, F_DIM_1, F, A_DIM_1, A_DIM_2, A, RW_DIM_1, RW, IER, RLSHEP_PRESENT, RLSHEP) BIND(C)
    USE REAL_PRECISION
    USE LINEAR_SHEPARD_MOD, ONLY: LSHEP
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: M
    INTEGER, INTENT(IN) :: N
    INTEGER, INTENT(IN) :: X_DIM_1
    INTEGER, INTENT(IN) :: X_DIM_2
    REAL(KIND=R8), INTENT(IN), DIMENSION(X_DIM_1,X_DIM_2) :: X
    INTEGER, INTENT(IN) :: F_DIM_1
    REAL(KIND=R8), INTENT(IN), DIMENSION(F_DIM_1) :: F
    INTEGER, INTENT(IN) :: A_DIM_1
    INTEGER, INTENT(IN) :: A_DIM_2
    REAL(KIND=R8), INTENT(OUT), DIMENSION(A_DIM_1,A_DIM_2) :: A
    INTEGER, INTENT(IN) :: RW_DIM_1
    REAL(KIND=R8), INTENT(OUT), DIMENSION(RW_DIM_1) :: RW
    INTEGER, INTENT(OUT) :: IER
    LOGICAL, INTENT(IN) :: RLSHEP_PRESENT
    LOGICAL, INTENT(INOUT) :: RLSHEP
  
    IF (RLSHEP_PRESENT) THEN
      CALL LSHEP(M=M, N=N, X=X, F=F, A=A, RW=RW, IER=IER, RLSHEP=RLSHEP)
    ELSE
      CALL LSHEP(M=M, N=N, X=X, F=F, A=A, RW=RW, IER=IER)
    END IF
  END SUBROUTINE C_LSHEP
  

  
  SUBROUTINE C_RIPPLE(M, N, X_DIM_1, X_DIM_2, X, F_DIM_1, F, A_DIM_1, A_DIM_2, A, RW_DIM_1, RW, IER) BIND(C)
    USE REAL_PRECISION
    USE LINEAR_SHEPARD_MOD, ONLY: RIPPLE
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: M
    INTEGER, INTENT(IN) :: N
    INTEGER, INTENT(IN) :: X_DIM_1
    INTEGER, INTENT(IN) :: X_DIM_2
    REAL(KIND=R8), INTENT(IN), DIMENSION(X_DIM_1,X_DIM_2) :: X
    INTEGER, INTENT(IN) :: F_DIM_1
    REAL(KIND=R8), INTENT(IN), DIMENSION(F_DIM_1) :: F
    INTEGER, INTENT(IN) :: A_DIM_1
    INTEGER, INTENT(IN) :: A_DIM_2
    REAL(KIND=R8), INTENT(OUT), DIMENSION(A_DIM_1,A_DIM_2) :: A
    INTEGER, INTENT(IN) :: RW_DIM_1
    REAL(KIND=R8), INTENT(OUT), DIMENSION(RW_DIM_1) :: RW
    INTEGER, INTENT(OUT) :: IER
  
    CALL RIPPLE(M, N, X, F, A, RW, IER)
  END SUBROUTINE C_RIPPLE
  

  
  SUBROUTINE C_LSHEPVAL(XP_DIM_1, XP, M, N, X_DIM_1, X_DIM_2, X, F_DIM_1, F, A_DIM_1, A_DIM_2, A, RW_DIM_1, RW, IER, LSHEPVAL_RESUL&
&T) BIND(C)
    USE REAL_PRECISION
    USE LINEAR_SHEPARD_MOD, ONLY: LSHEPVAL
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: XP_DIM_1
    REAL(KIND=R8), INTENT(IN), DIMENSION(XP_DIM_1) :: XP
    INTEGER, INTENT(IN) :: M
    INTEGER, INTENT(IN) :: N
    INTEGER, INTENT(IN) :: X_DIM_1
    INTEGER, INTENT(IN) :: X_DIM_2
    REAL(KIND=R8), INTENT(IN), DIMENSION(X_DIM_1,X_DIM_2) :: X
    INTEGER, INTENT(IN) :: F_DIM_1
    REAL(KIND=R8), INTENT(IN), DIMENSION(F_DIM_1) :: F
    INTEGER, INTENT(IN) :: A_DIM_1
    INTEGER, INTENT(IN) :: A_DIM_2
    REAL(KIND=R8), INTENT(IN), DIMENSION(A_DIM_1,A_DIM_2) :: A
    INTEGER, INTENT(IN) :: RW_DIM_1
    REAL(KIND=R8), INTENT(IN), DIMENSION(RW_DIM_1) :: RW
    INTEGER, INTENT(OUT) :: IER
    REAL(KIND=R8) :: LSHEPVAL_RESULT
  
    LSHEPVAL_RESULT = LSHEPVAL(XP, M, N, X, F, A, RW, IER)
  END SUBROUTINE C_LSHEPVAL
  
END MODULE C_LINEAR_SHEPARD_MOD

