# Given a list of values, compute the median of medians. When the
# group_size integer is 5, the returned number is guaranteed to be
# between the 30th and 70th percentiles.
def median_of_medians(values, group_size=5):
    if (len(values) <= group_size): return bubble_median(values)
    # Swap all medians into first (values // group_size) elements.
    for i in range(0,len(values)//group_size):
        mid_ind = bubble_median(values[group_size*i,group_size*(i+1)])
        values[i], values[mid_ind] = values[mid_ind], values[i]
    # Recursively use "partition" function to find median of medians.
    return select(values[:i+1], i//2)[i//2]

# Partition the provided 1D list of numbers "values" such that the
# "i"th element in the list is the "i"th largest value.
def partition(values, pivot, i):
    # Move the pivot value to the end.
    values[-1], values[pivot] = values[pivot], values[-1]
    sorter = values[-1]
    done = 0
    # Move all values "< sorter" to the left.
    for i in range(len(values)-1):
        if values[i] < sorter:
            values[done], values[i] = values[i], values[done]
            done += 1
    # If the selected index "i" is left of the partition, then return
    # the right edge of the partition (to be used as a new upper bound).
    if (i < done): return done
    # Move all values "= sorter" to the middle (left).
    for i in range(len(values)-1):
        if values[i] == sorter:
            values[done], values[i] = values[i], values[done]
            done += 1
    # Move the pivot value back into its proper place (end of the equals).
    values[done], values[-1] = values[-1], values[done]
    # If the selected index "i" is inside the 'equals' range, then
    # just return the value "i", because the selection is done.
    if (i <= done): return i
    # Finally, if the index is greater than "done", then return the
    # index starting the right side of the partition for further search.
    else:           return done

def select(values, i): pass


nearest_pairs = []
    pairs = []
        pairs.append( (dim, nearest_dim) )
    # Record the matchings.
    nearest_pairs.append(pairs)

# Use apriori tree to mine the most frequently occuring sets of items.    
from util.misc.apriori import AprioriTree
a = AprioriTree(support=.01)
item_sets = a.mine_items(nearest_pairs, longest_item=3)
for item_set in item_sets: 
    items = list(item_set.items())
    items.sort(key=lambda i: -i[1])
    for i in items: print("%s: %0.1f%%"%(i[0], 100.0*i[1]))
    print()





#     diff = abs(points[i][None,:] - points[nearest][:,None]).flatten()
#     diffs.append(diff.flatten())

# diffs = np.array(diffs)
# np.set_printoptions(precision=3, suppress=True, linewidth=2000, edgeitems=20, sign=' ')
# cov_mat = np.cov(diffs, rowvar=False)
# print(cov_mat)


# Use apriori tree to mine the most frequently occuring sets of items.    
from util.misc.apriori import AprioriTree
a = AprioriTree(support=.01)
item_sets = a.mine_items(all_mappings, longest_item=3)
for item_set in item_sets: 
    items = list(item_set.items())
    items.sort(key=lambda i: -i[1])
    for i in items: print("%s: %0.1f%%"%(i[0], 100.0*i[1]))
    print()


