from util.plotly import Plot
# from util.approximate import minimize
from util.optimize import minimize
import numpy as np
from vmesh import VoronoiMesh
import time

p = Plot()
# for n in range(1000,10001, 1000):
#     for d in range(2,13,1):
#         v = VoronoiMesh()
#         points = np.random.random((n,d))
#         start = time.time()
#         v.fit( points, np.ones((n,)) )
#         v(np.array([[0.5,0.5]]))
#         total = time.time() - start
#         print("[%i, %i, %f]"%(n,d,total))
        
pts = np.array([
    [0, 2, 0],
    [0, 3, 0],
    [0, 4, 0],
    [0, 5, 0],
    [0, 6, 0],
    [0, 7, 0],
    [0, 8, 0],
    [0, 9, 0],
    [0, 10, 0],
    [0, 11, 0],
    [0, 12, 0],
    [1000, 2, 0.133740],
    [1000, 3, 0.173052],
    [1000, 4, 0.204128],
    [1000, 5, 0.000243],
    [1000, 6, 0.267483],
    [1000, 7, 0.000293],
    [1000, 8, 0.000210],
    [1000, 9, 0.357937],
    [1000, 10, 0.000330],
    [1000, 11, 0.419876],
    [1000, 12, 0.453359],
    [2000, 2, 0.511481],
    [2000, 3, 0.661542],
    [2000, 4, 0.777545],
    [2000, 5, 0.000355],
    [2000, 6, 0.940577],
    [2000, 7, 1.149192],
    [2000, 8, 1.299609],
    [2000, 9, 1.380387],
    [2000, 10, 1.637903],
    [2000, 11, 1.631761],
    [2000, 12, 0.000420],
    [3000, 2, 1.150702],
    [3000, 3, 1.438090],
    [3000, 4, 0.000492],
    [3000, 5, 2.016605],
    [3000, 6, 2.303649],
    [3000, 7, 2.566217],
    [3000, 8, 2.561089],
    [3000, 9, 3.123293],
    [3000, 10, 3.496216],
    [3000, 11, 3.369468],
    [3000, 12, 3.633269],
    [4000, 2, 2.000922],
    [4000, 3, 2.559254],
    [4000, 4, 3.041570],
    [4000, 5, 3.552305],
    [4000, 6, 3.674956],
    [4000, 7, 4.123719],
    [4000, 8, 4.614784],
    [4000, 9, 5.057631],
    [4000, 10, 5.588708],
    [4000, 11, 5.976319],
    [4000, 12, 6.434105],
    [5000, 2, 3.133149],
    [5000, 3, 3.769979],
    [5000, 4, 4.779831],
    [5000, 5, 4.984124],
    [5000, 6, 6.774480],
    [5000, 7, 6.863208],
    [5000, 8, 7.297310],
    [5000, 9, 8.274979],
    [5000, 10, 9.172679],
    [5000, 11, 9.369319],
    [5000, 12, 9.579106],
    [6000, 2, 4.460629],
    [6000, 3, 5.417666],
    [6000, 4, 6.226009],
    [6000, 5, 7.935096],
    [6000, 6, 9.093502],
    [6000, 7, 9.687290],
    [6000, 8, 10.278645],
    [6000, 9, 11.292944],
    [6000, 10, 13.158397],
    [6000, 11, 13.452215],
    [6000, 12, 14.415823],
    [7000, 2, 6.025096],
    [7000, 3, 7.696930],
    [7000, 4, 8.774064],
    [7000, 5, 10.794980],
    [7000, 6, 11.847372],
    [7000, 7, 13.870187],
    [7000, 8, 13.897225],
    [7000, 9, 15.323302],
    [7000, 10, 16.946313],
    [7000, 11, 17.346141],
    [7000, 12, 19.599186],
    [8000, 2, 7.882297],
    [8000, 3, 9.243748],
    [8000, 4, 12.059664],
    [8000, 5, 12.755589],
    [8000, 6, 14.530033],
    [8000, 7, 16.390924],
    [8000, 8, 18.074779],
    [8000, 9, 20.037233],
    [8000, 10, 24.367623],
    [8000, 11, 23.313450],
    [8000, 12, 24.551037],
    [9000, 2, 10.217997],
    [9000, 3, 13.228231],
    [9000, 4, 15.443518],
    [9000, 5, 17.962272],
    [9000, 6, 19.001224],
    [9000, 7, 21.456662],
    [9000, 8, 23.091738],
    [9000, 9, 24.908802],
    [9000, 10, 28.031348],
    [9000, 11, 28.833788],
    [9000, 12, 35.554446],
    [10000, 2, 12.635794],
    [10000, 3, 15.768087],
    [10000, 4, 19.203930],
    [10000, 5, 23.461183],
    [10000, 6, 25.427547],
    [10000, 7, 26.547624],
    [10000, 8, 30.911956],
    [10000, 9, 30.772051],
    [10000, 10, 37.053526],
    [10000, 11, 36.662731],
    [10000, 12, 42.171403],
    # [0,    0.0],
    # [1000, 0.12],
    # [2000, 0.47],
    # [3000, 1.03],
    # [4000, 1.89],
    # [5000, 2.83],
    # [6000, 4.08],
    # [7000, 5.58],
    # [8000, 7.12],
    # [9000, 9.12],
    # [10000, 11.14]
])

# Solve the actual least-squares problem
A = np.concatenate(([pts[:,1]*pts[:,0]**2], [pts[:,1]*pts[:,0]], [pts[:,1]])).T
B = pts[:,-1]
a,b,c = np.linalg.lstsq(A,B)[0]
print("Actual: d (%.3e x^2  +  %.3e x  +  %.3e)"%(a,b,c))

# Solve the least squares as an optimizaiton problem
fun = lambda c: sum(
    (pts[:,1]*(c[0]*pts[:,0]**2 + c[1]*pts[:,0]**1 + c[2]*pts[:,0]**0)
     -pts[:,-1])**2)
a,b,c = minimize(fun, [0,0,0])
print("Approx: d (%.3e x^2  +  %.3e x  +  %.3e)"%(a,b,c))

# Add the fit function to the plot
fit = lambda x: x[1]*(a*x[0]**2 + b*x[0] + c)
p.add("Points", *(pts.T))
p.add_func("Fit", fit,[0,10000],[2,12])
p.plot()

def ydhm(total_seconds):
    minutes = total_seconds / 60
    minutes, hours = minutes%60, (minutes-minutes%60) / 60
    hours, days = hours%24, (hours-hours%24) / 24
    days, years = days%365, (days-days%365) / 365
    return years, days, hours, minutes

n = 50
d = 1000000000
print("%i dimensions:"%d)
for n in range(10,101,10):
    print(("%i points: %i years, %i days, %i hours, %i "+
           "minutes")%(n,*ydhm(fit((n,d)))))
