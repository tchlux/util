import numpy as np

# Pre:  "iterable" is a list type, "value" is an iterable whose
#       elements have comparison operators, "key" is a function to use
#       for sorting
# Post: A binary search over the iterable is performed and "value" is
#       inserted in a sorted order left of anything with equal key,
#       "key" defaults to sorting by the last element of "value"
def insert_sorted(iterable, value, key=lambda i:i[-1]):
    low = 0
    high = len(iterable)
    index = (low + high) // 2
    while high != low:
        if key(iterable[index]) >= key(value):   high = index
        elif key(iterable[index]) < key(value):  low = index + 1
        index = (low + high) // 2
    iterable.insert(index, value)

class Rect:
    # Pre:  "center" is a numpy array that represents the center of
    #         this hyper rectangle,
    #       "sides" is a numpy array that represents the lengths of
    #         each of the sides of this hyper rectangle (all positive)
    # Post: Member data stored for use
    def __init__(self, center, sides, obj_value):
        self.center = center
        self.sides = sides
        self.diameter = max(sides)
        self.obj = obj_value

    # Post: Returns a numpy array with all new center points along the
    #         primary axis, generated by shifting one-third of the
    #         longest side length on each axis of that length, also
    #         sorted in lexicographical order
    def divide(self):
        shift = self.diameter / 3.0
        mask = np.where(self.sides >= self.diameter)
        ident = np.identity(self.center.shape[0])[mask]
        lower = self.center - ident*shift
        upper = self.center + ident*shift
        return (lower, upper)

# Pre:  "rects" is a dictionary of {length:sorted list of rectangles}
#         where the sorted list is sorted by objective function value,
#       "to_beat" is the objective value to beat
# Post: Figures out which rectangles are potentially optimal by first
#         getting the best rectangle of each diameter, then
#         identifying those of that set that are along the convex hull
#         of the plot of diameter versus objective function value
def get_potential_best(rects, to_beat):
    # Get the list of (diameter, best objective function value) and
    # sort the list (by default sorts by diameter, which are all unique)
    to_divide = sorted((d, rects[d][0].obj) for d in rects)
    # Add the objective value that needs to be beaten to the front
    to_divide = [ (0, to_beat) ] + to_divide
    # Use a loop to find the convex hull
    slopes = []
    # Continue looping until we have made it to the end of the list
    while len(slopes) + 1 < len(to_divide):
        curr = len(slopes) + 1
        # Get the slope from previous point to the current point
        slope = (to_divide[curr][1] - to_divide[curr-1][1]) / \
                (to_divide[curr][0] - to_divide[curr-1][0])
        # If no points are in the hull yet, or slope is increasing
        if len(slopes) == 0 or slope > slopes[-1]:
            # Add this point to the hull and increment "current" counter
            slopes.append(slope)
        else: # Else the previous point wasn't actually on the hull
            # Remove that point from potential hull points and its slope
            to_divide.pop(curr-1)
            slopes.pop(-1)
    # Remove the extra starting point added for cutoff
    to_divide.pop(0)
    # Return the list of increasing diameters of potentially optimal rects
    return [diameter for (diameter, obj) in to_divide]

# Pre:  "objective" a numpy array and returns an object that has a
#         comparison operator 
#       "halt" is a function that takes no parameters and returns
#         "False" when the algorithm should continue and "True" when
#         it should halt
#       "bounds" is a list of tuples (lower,upper) for each parameter
#       "solution" an initial solution that is disregarded.
#       "args" are additional arguments that need to be passed to "objective".
# Post: Returns an (objective value, solution) tuple, best achieved
def DiRect(objective, halt, bounds, _=None, min_improvement=0.0001, args=tuple()):
    # Extract range information for each dimension
    ranges = np.array( [ upper-lower for (lower,upper) in bounds] )
    lowers = np.array( [lower for (lower,_) in bounds] )
    # Define a new objective function in terms of the unit hypercube
    obj_func = lambda s: objective( (s*ranges) + lowers, *args )
    # Initialize the first rectangle (the entire area)
    center = np.array([0.5] * len(bounds))
    sides = np.array([1.0] * len(bounds))
    r = Rect(center, sides, obj_func(center))
    # Initialize the holder for all rectangles
    rects = { r.diameter:[ r ] }    
    best_rect = r
    # DiRect primary search loop of dividing potentially optimal rectangles
    while not halt():
        # Establish a starting point based on the best function value
        to_beat = best_rect.obj - abs(best_rect.obj * min_improvement)
        # Get the list of rectangles that are potentially optimal
        # (best obj from each diameter, some excluded w/ convex hull)
        to_divide = get_potential_best(rects, to_beat)
        # Divide all of the potentially optimal rectangles
        for diam in to_divide:            
            # Get all rectangles at this diameter with equal objective value
            to_split = [rects[diam].pop(0)]
            obj = to_split[0].obj
            while len(rects[diam]) > 0 and rects[diam][0].obj <= obj:
                to_split.append( rects[diam].pop(0) )
            # Remove lengths that have no more rectangles
            if len(rects[diam]) == 0:
                rects.pop(diam)
            # Order them lexicographically by center point location
            to_split.sort( key=lambda i: list(i.center) )
            # Cycle through these rectangles and divide them
            for r in to_split:
                diameter = r.diameter
                # Get the sample points determined by division
                lower, upper = r.divide()
                # Calculate the objective function value for all of these
                obj_values = [(i, obj_func(lower[i]), obj_func(upper[i]))
                              for i in range(lower.shape[0])]
                # Sort these pairs of lower and upper sample points by
                # their minimum objective function values
                obj_values.sort(key=lambda i: min(i[1], i[2]))
                # Cycle through new centers and objective values
                # starting with the pair of (lower, upper) with best value
                for index, l_obj, u_obj in obj_values:
                    # Find out which dimension the "delta" is on and its magnitude
                    dimension = np.argmax(r.center - lower[index])
                    shift = r.center[dimension] - lower[index][dimension]
                    # Adjust the side length of the center point to be
                    # that shift (since it is 1/3 the original length)
                    r.sides[dimension] = shift
                    # Initialize the two new rectangles 
                    #  (same dimensions as the center point)
                    low_rect = Rect(lower[index], r.sides.copy(), l_obj)
                    up_rect = Rect(upper[index], r.sides.copy(), u_obj)
                    # The diameters are all the same, but verify that
                    # there is a place in the master list for these new rects
                    if low_rect.diameter not in rects:
                        rects[low_rect.diameter] = []
                    # Insert the new rectangles into the master list
                    # sorted by objective function value
                    insert_sorted(rects[low_rect.diameter], 
                                  low_rect, key=lambda i: i.obj)
                    insert_sorted(rects[up_rect.diameter], 
                                  up_rect, key=lambda i: i.obj)
                    # Update the "best rect" seen so far
                    if low_rect.obj < best_rect.obj:
                        # Copy in order to avoid side effects of division
                        best_rect = Rect(low_rect.center, 
                                         low_rect.sides.copy(),
                                         low_rect.obj)
                    if up_rect.obj < best_rect.obj:
                        best_rect = Rect(up_rect.center, 
                                         up_rect.sides.copy(),
                                         up_rect.obj)
                # Update the diameter of the center point
                r.diameter = max(r.sides)
                # Finally, re-insert the divided center point
                insert_sorted(rects[r.diameter], r, 
                              key=lambda i:i.obj)                
                # Check halting condition, return best (obj, point)
                if halt(): return (best_rect.obj, best_rect.center*ranges + lowers)
    # Primary while loop terminated, return best (obj, point)
    return (best_rect.obj, best_rect.center*ranges + lowers)
                
            
