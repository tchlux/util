            # print()
            # print(min_l, num_steps)
            # print(max(self.y / distances),
            #       min(self.y / distances))
            # print((max(self.y / distances) + 
            #        min(self.y / distances)) / 2)
            # print(np.argmax(self.y - distances * min_l),
            #       np.argmin(self.y + distances * min_l))
            # print(np.argmax(self.y / distances),
            #       np.argmin(self.y / distances))
            # min_l += 1

class BoxMesh(Approximator):
    def __init__(self):
        self.box_mesh = fmodpy.fimport(
            os.path.join(CWD,"meshes","meshes.f90"),
            module_link_args=["-lgfortran","-lblas","-llapack"], 
            output_directory=CWD)
        self.points = None
        self.values = None

    # Fit a set of points
    def fit(self, points, values=None):
        self.points = np.asarray(points.T.copy(), order="F")
        if type(values) != type(None):
            self.values = np.asarray(values.copy(), order="F")
        self.shapes = np.ones((self.points.shape[0]*2,self.points.shape[1]), order="F")
        # Compute all of the max-boxes
        self.max_box_mesh.max_boxes(self.points, self.shapes)
        # Expand all boxes (to make the mesh space-filling)
        self.shapes += SMALL_NUMBER

    # Calculate the weights associated with a set of points
    def points_and_weights(self, x):
        single_response = len(x.shape) == 1
        if single_response:
            x = np.array([x])
        if len(x.shape) != 2:
            raise(Exception("ERROR: Bad input shape."))

        x = np.array(x.T, order="F")
        weights = np.ones((x.shape[1], self.points.shape[1]), 
                          dtype=np.float64, order="F")
        self.max_box_mesh.eval_box_mesh(self.points, self.shapes,
                                        x, weights)

        # Make all weights convex
        for i,w in enumerate(np.sum(weights,axis=1)):
            weights[i,:] /= w
        points = np.zeros(weights.shape, dtype=int) + np.arange(self.points.shape[1])
        # Return the appropriate shaped pair of points and weights
        return points, weights

    # Generate a prediction for a new point
    def predict(self, xs):
        if type(self.values) == type(None):
            raise(Exception("Must provide values in order to make predicitons."))
        weights = self.points_and_weights(xs)
        predictions = np.matmul(weights, self.values)
        return predictions



# class VoronoiMesh(Approximator):
#     def __init__(self):
#         self.voronoi_mesh = fmodpy.fimport(
#             os.path.join(CWD,"voronoi_mesh","voronoi_mesh.f90"),
#             module_link_args=["-lgfortran","-lblas","-llapack"], 
#             output_directory=CWD)
#         self.points = None
#         self.values = None

#     # Fit a set of points
#     def fit(self, points, values=None):
#         self.points = np.asarray(points.T.copy(), order="F")
#         if type(values) != type(None):
#             self.values = np.asarray(values.copy(), order="F")
#         self.dots = np.ones((points.shape[0],)*2, order="F")
#         # Compute all of the pairwise dot products between control points
#         self.voronoi_mesh.train_vm(self.points, self.dots)

#     # Calculate the weights associated with a set of points
#     def points_and_weights(self, x, convex=True):
#         single_response = len(x.shape) == 1
#         if single_response:
#             x = np.array([x])
#         if len(x.shape) != 2:
#             raise(Exception("ERROR: Bad input shape."))
#         x = np.array(x.T, order="F")
#         weights = np.ones((x.shape[1], self.points.shape[1]), 
#                           dtype=np.float64, order="F")
#         self.voronoi_mesh.predict_vm(self.points, self.dots,
#                                      x, weights)
#         if convex:
#             # Make all the weights convex
#             weights = (weights.T / np.sum(weights,axis=1)).T
#         # Generate the list of point indices
#         points = np.zeros(weights.shape, dtype=int) + np.arange(self.points.shape[1])
#         # Return the appropriate shaped pair of points and weights
#         return points, weights

#     # Generate a prediction for a new point
#     def predict(self, xs):
#         if type(self.values) == type(None):
#             raise(Exception("Must provide values in order to make predicitons."))
#         weights = self.points_and_weights(xs)
#         # Generate the predictions
#         return np.matmul(weights, self.values)


